package topicmodeling;

import processor.ToolsProcessor.StanfordParserProcessor;
import data.Comment;
import data.Token;
import data.Target;
import topicmodeling.CoreferenceFeatures;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import util.FileReader;

  public static Boolean MatchPersonArabic(Token t1, Token t2) {
		if (t1.morph_features == null || t2.morph_features == null) {
			return false;
		}
		else if (t1.morph_features.containsKey("NO_ANALYSIS") 
				|| t2.morph_features.containsKey("NO_ANALYSIS")) {
			return false;
		}
		else {
			if (!(t1.morph_features.get("per").equals(t2.morph_features.get("per")))) {
				System.out.println("person mismatch!");
			}
				System.out.println("t1:" + t1.morph_features.get("per"));
				System.out.println("t2:" + t2.morph_features.get("per"));
			
			return t1.morph_features.get("per").equals(t2.morph_features.get("per"));
		}
	}


	// Returns the index of the head noun given this NP node
	// NN, NNS (noun, plural!), NNP (proper noun singular), 
	// NNPS (proper noun plural), DTNN, DTNNS, DTNNP, DTNNPS ...
	// probably won't need nodes just leafs
	/*public static int HeadNounIndexFromNPNode(Element antecedant_node, List<Node> leafs) {
		System.out.println("Finding index of antecedant");
		int index = 0;
		System.out.println("Antecedant:" + antecedant_node.getAttribute("value"));
		List<Node> children = ElementChildren(antecedant_node);
		Element child = (Element) children.get(0);
		// do BFS and search for first NN, NNS, NNP ////
		/*while (child.getAttribute("value").equals("NP")) {
			child = (Element) ElementChildren(child).get(0);
			children = ElementChildren(child);
		}*/
		/*System.out.println("Child:" + child.getAttribute("value"));
		int sibling = 0;
		while ( !child.getAttribute("value").equals("NN") 
				&& !child.getAttribute("value").equals("NNS") 
				&& !child.getAttribute("value").equals("NNP") 
				&& !child.getAttribute("value").equals("NNPS")
				&& !child.getAttribute("value").equals("DTNN")
				&& !child.getAttribute("value").equals("DTNNS")
				&& !child.getAttribute("value").equals("DTNNP")
				&& !child.getAttribute("value").equals("DTNNPS")
				&& child!=null
				&& sibling < children.size()-1) {
			child = (Element) children.get(sibling+1);
			sibling +=1;
		}
		System.out.println("Child:" + child.getAttribute("value"));
		while (child.hasChildNodes()) {
			// should only have one child at this point
			child = (Element) ElementChildren(child).get(0);
		}
		if (child == null || !leafs.contains((Node) child)) {
			System.out.println("Hobbs: Tried to find the head noun,"
					+ " but turns out leafs doesn't contain this child.");
			return -1;
		}  else {
			index = leafs.indexOf(child);
			return index;
		}
	}*/

	
	// TODO
	// can add parameter node P to exclude this subtree
	/*public static List<Node> BFSChildren(Node X) {
		List<Node> Xchild_BFS_list = new ArrayList<Node>();
		List<Node> Xchilds = ElementChildren(X);
 		
		for (int j=0; j<Xchilds.size();j++) {
			
			Node childNode = Xchilds.get(j);
			
			/*if (childNode.getNodeType() == Node.ELEMENT_NODE) {
					Xchild_BFS_list.add(childNode);
				}
			}*/
		/*}
		return Xchild_BFS_list;
	}*/
	

public static List<Node> ElementChildren(Node X) {
		List<Node> Xchild_list = new ArrayList<Node>();
		NodeList Xchilds = X.getChildNodes();
		for (int j=0; j<Xchilds.getLength();j++) {
			Node childNode = Xchilds.item(j);
			if (childNode.getNodeType() == Node.ELEMENT_NODE) {
					Xchild_list.add(childNode);
					//System.out.println("Child:" + j);
					//System.out.println("X child value: " + ((Element) childNode).getAttribute("value"));
					
					/*if (childNode.equals(P_node)) {
						System.out.println("This X child is P node!"); // this works
					}
					//System.out.println("X child: " + childNode.getNodeName());
					//System.out.println("X child: " + childNode.getFirstChild().getNodeValue());
					System.out.println("X child: " + childNode.getTextContent());*/
				}
			}
		return Xchild_list;
		//System.out.println("Number of child nodes:" + Xchilds.getLength());
		// There are 5 but really only 2 are element nodes, the first child and P (in 
		// the first example) // so need to get only the element nodes and add them 
		// in a list, then do the breadth first search
	}

	// old step 6, this is wrong anyway, it should return X not left child
	/*if (P.getPreviousSibling().getNodeType() == Node.ELEMENT_NODE) {
				left_child = (Element) P.getPreviousSibling();
			} else {
				System.out.println("Sibling is not of type element node!");
			}
			while ( left_child!=null
					&&!left_child.getAttribute("value").equals("NN")
					&& !left_child.getAttribute("value").equals("NNS") 
					&& !left_child.getAttribute("value").equals("NNP")
					&& !left_child.getAttribute("value").equals("NNPS")
					&& !left_child.getAttribute("value").equals("DTNN") 
					&& !left_child.getAttribute("value").equals("DTNNS")
					&& !left_child.getAttribute("value").equals("DTNNP")
					&& !left_child.getAttribute("value").equals("DTNNPS")
					) {
				left_child = (Element) left_child.getPreviousSibling();
			}	
			if (left_child !=null ) {
			System.out.println("Left child:" + left_child.getAttribute("value"));
			}
		
		return left_child;*/

/*public static Element AntecedantStep8(Node X, Node P) {
		Element antecedant = null;
		if (!X.getAttribute("value").equals("S")) {
			return antecedant;
		}
		if (X.getAttribute("value").equals("S")) {
			Element right_child = (Element) P.getNextSibling();
			Element first_child =  right_child;
			while (right_child != null) {
					if (right_child.getAttribute("value").equals("NP")) {
						antecedant = right_child;
						break;
					}
					if (right_child.getNextSibling() == null) {
						// Go to uncle or aunt tree
						if (right_child.getParentNode().getNextSibling()!=null) {
							right_child = (Element) 
									right_child.getParentNode().getNextSibling().getFirstChild();
							first_child = right_child;
						} 
						else {
							// Go to next level in tree
							right_child = (Element) first_child.getFirstChild();
							first_child = right_child;
						}
					}
					else {
						right_child = (Element) right_child.getNextSibling(); 
					}
					// If right child is still null, no more children, so exit
				}	 		
		}
		return antecedant;
	}*/

/*public static Element AntecedantStep7(Element X, Element P) {
		Element antecedant = null;
		Element left_child = (Element) X.getFirstChild();
		Element first_child =  left_child;
		if (!left_child.equals(P)) {
			while (left_child != null) {
				if (left_child.getAttribute("value").equals("NP")) {
					antecedant = left_child;
					break;
				}
				if (left_child.getNextSibling()==null
						|| left_child.getNextSibling().equals(P)) {
					// Go to uncle or aunt tree
					if (!left_child.getNextSibling().equals(P) && left_child.getParentNode().getNextSibling()!=null
							&& !left_child.getParentNode().getNextSibling().equals(P)) {
						left_child = (Element) left_child.getParentNode().getNextSibling().getFirstChild();
						first_child = left_child;
					} 
					else {
						// Go to next level in tree
						left_child = (Element) first_child.getFirstChild();
						first_child = left_child;
					}
				 } 
				else {
					left_child = (Element) left_child.getNextSibling(); 
				}
			  } // If left child is still null, no more children, so exit
			} // If P is the only child, do nothing
		return antecedant;
	}*/
	


public class HobbsCoreference {
	
	// Takes as input comments and xml parse trees, and returns comments updated with 
	// pronominal coreference fields
	public static List<Comment> Update(List<Comment> feature_comments, Document parse_trees) {
		NodeList p_list = parse_trees.getElementsByTagName("s");
		if (feature_comments.size() != p_list.getLength()) {
			System.out.println("Couldn't update coreference features. Size of comments "
					+ "does not match number of parse trees. Continuing without coreference.\n");
			return feature_comments;
		}
		for (int p=0; p < p_list.getLength(); p++) { 
			Comment c = feature_comments.get(p);
			Node s_node = p_list.item(p);
			c = UpdateTokens(c, s_node);
		}
		return feature_comments;
	}
	
	// have to pass the node?
	public static Element AntecedantStep3(Element X, Element P) {
		Element antecedant = null;
		Element left_child = (Element) X.getFirstChild();
		Element first_child = left_child;
		if (!left_child.equals(P)) {
			while (left_child != null) {
				if (left_child.getAttribute("value").equals("NP")) {
				// check if there is NP node between left child and X, go up the tree again
					Element potential_parent = (Element) left_child.getParentNode();
					while (!potential_parent.equals(X)) {
						if (potential_parent.getAttribute("value").equals("NP")
								|| potential_parent.getAttributeNode("value").equals("S")) {
							antecedant = left_child;
							break;
							// also match
						}
						potential_parent = (Element) potential_parent.getParentNode();
					}
				}
				if (antecedant != null) {
					break;
				}
				if (left_child.getNextSibling()==null || left_child.getNextSibling().equals(P)) {
					// Go to uncle or aunt tree
					if (!left_child.getNextSibling().equals(P) && left_child.getParentNode().getNextSibling()!=null
							&& !left_child.getParentNode().getNextSibling().equals(P)) {
						left_child = (Element) left_child.getParentNode().getNextSibling().getFirstChild();
						first_child = left_child;
					} 
					else {
						// Go to next level in tree
						left_child = (Element) first_child.getFirstChild();
						first_child = left_child;
					}
				 } 
				else {
					left_child = (Element) left_child.getNextSibling(); 
				}
			}  // If left child is still null, no more children, so exit
		}  // If P is the only child, do nothing
		return antecedant;
	}

	public static Element AntecedantStep6(Element X, Element P) {
		Element left_child = null;
		if (X.getAttribute("value").equals("NP")) {
			left_child = (Element) P.getPreviousSibling();
			while ( !left_child.getAttribute("value").equals("NN")
					&& !left_child.getAttribute("value").equals("NNS") 
					&& !left_child.getAttribute("value").equals("NNP")
					&& !left_child.getAttribute("value").equals("NNPS")
					&& !left_child.getAttribute("value").equals("DTNN") 
					&& !left_child.getAttribute("value").equals("DTNNS")
					&& !left_child.getAttribute("value").equals("DTNNP")
					&& !left_child.getAttribute("value").equals("DTNNPS")
					&& left_child!=null) {
				left_child = (Element) left_child.getPreviousSibling();
			}	
		}
		return left_child;
	}
		
	public static Element AntecedantStep7(Element X, Element P) {
		Element antecedant = null;
		Element left_child = (Element) X.getFirstChild();
		Element first_child =  left_child;
		if (!left_child.equals(P)) {
			while (left_child != null) {
				if (left_child.getAttribute("value").equals("NP")) {
					antecedant = left_child;
					break;
				}
				if (left_child.getNextSibling()==null || left_child.getNextSibling().equals(P)) {
					// Go to uncle or aunt tree
					if (!left_child.getNextSibling().equals(P) && left_child.getParentNode().getNextSibling()!=null
							&& !left_child.getParentNode().getNextSibling().equals(P)) {
						left_child = (Element) left_child.getParentNode().getNextSibling().getFirstChild();
						first_child = left_child;
					} 
					else {
						// Go to next level in tree
						left_child = (Element) first_child.getFirstChild();
						first_child = left_child;
					}
				 } 
				else {
					left_child = (Element) left_child.getNextSibling(); 
				}
			  } // If left child is still null, no more children, so exit
			} // If P is the only child, do nothing
		return antecedant;
	}
	
	public static Element AntecedantStep8(Element X, Element P) {
		Element antecedant = null;
		if (X.getAttribute("value").equals("S")) {
			Element right_child = (Element) P.getNextSibling();
			Element first_child =  right_child;
			while (right_child != null) {
					if (right_child.getAttribute("value").equals("NP")) {
						antecedant = right_child;
						break;
					}
					if (right_child.getNextSibling() == null) {
						// Go to uncle or aunt tree
						if (right_child.getParentNode().getNextSibling()!=null) {
							right_child = (Element) 
									right_child.getParentNode().getNextSibling().getFirstChild();
							first_child = right_child;
						} 
						else {
							// Go to next level in tree
							right_child = (Element) first_child.getFirstChild();
							first_child = right_child;
						}
					}
					else {
						right_child = (Element) right_child.getNextSibling(); 
					}
					// If right child is still null, no more children, so exit
				}	 		
		}
		return antecedant;
	}
	
	// For coreferring pronominal mentions, updates their coreference fields
	// Fills in Al+ for ATB
	//
	// TODO: need node list?
	// TODO: any misalignment between stanford parses and Madamira?
	public static Comment UpdateTokens(Comment feature_comment, Node parse_tree) {
			System.out.println("\nRunning Hobbs: Comment id:" + feature_comment.comment_id_);
			Element e_element = (Element) parse_tree;
			NodeList nodes = e_element.getElementsByTagName("node");
			NodeList leafs = e_element.getElementsByTagName("leaf");
			List<Node> leaf_list = GetLeafList(leafs);
			int node = 0;
			// i loop to update Al+ tokens?
			for (int i=0; i<feature_comment.tokens_.size(); i++) {
				Token t = feature_comment.tokens_.get(i);
				if (t.text_.equals("Al+")) {
					continue;
				}
				
				Node leaf_node =  leafs.item(node);
				Node parent_node = leaf_node.getParentNode();
				Element parent_element = (Element) parent_node;
				Element leaf_element = (Element) leaf_node;
				//Element parent_element = (Element) leaf_element.getParentNode(); // need nodes structure?
				String leaf_POS = parent_element.getAttribute("value");
				
				if (leaf_POS.equals("PRP") || leaf_POS.equals("PRP$")) {
					//FindAntecedant(leaf_element,)
					//int antecedant = FindAntecedant(leaf_element, t, parse_tree);
					Element antecedant = null;
					int antecedant_node = -1;
					Token antecedant_token = null;
					
					// Step 1: go to NP node immediately dominating pronoun
					Node p_node = parent_node.getParentNode();
					Element parent = (Element) p_node;
					//Element parent = (Element) parent_element.getParentNode();
					while (!parent.getAttribute("value").equals("NP")) {
						p_node = p_node.getParentNode();
						parent = (Element) p_node;
						//parent = (Element) parent.getParentNode();
					}
					
					// Step 2: Go up the tree to the first NP or S node encountered. 
					// Call this node X, and call the path used to reach it p.
					Node P_node = p_node;
					Node X_node= p_node.getParentNode();
					Element P = (Element) P_node;
					Element X= (Element) X_node;
					//Element P = parent;
					//Element X = (Element) parent.getParentNode();
					while (!X.getAttribute("value").equals("NP") && !X.getAttribute("value").equals("S")) {
						P = X;
						X = (Element) X.getParentNode();
					}
					
					// Step 3: Traverse all branches below node X to the left of path p
					// in a left-to-right, breadth-first fashion. Propose as the antecedant
					// any NP node that is encountered which has an NP or S node beween it and X.
					// (This step takes care of the level of the tree where there are 
					// reflexive pronouns.) 
					antecedant = AntecedantStep3(X,P);
					
					// Match antecedant
					if (antecedant!=null) {
						//antecedant_node = HeadNounIndexFromNPNode(antecedant, nodes, leafs); 
						antecedant_node = HeadNounIndexFromNPNode(antecedant, leaf_list);
						if (antecedant_node == -1) {
							System.out.println("Antecedant index is -1 :( ");
							antecedant = null;
						}
						Token t2 = feature_comment.tokens_.get(antecedant_node);
						if (!CoreferenceFeatures.MatchGenderArabic(t, t2) 
							|| !CoreferenceFeatures.MatchNumberArabic(t, t2) 
							|| !CoreferenceFeatures.MatchPersonArabic(t, t2)) {
							System.out.println("Antecedant doesn't match gender, number, or person! "
									+ "Moving on to next rule");
							System.out.println("Pronoun:" + t.text_);
							System.out.println("Antecedant:" + t2.text_);
							antecedant = null;
						} else {
							System.out.println("Found antecedant!");
							antecedant_token = t2;
							// Passed, make all updates
							t.SetCoreferrent(true);
							t.SetCoreferringTarget(antecedant_token);
							System.out.println("Pronoun:" + t.text_);
							System.out.println("Antecedant:" + antecedant_token.text_);
							if (i>0 && feature_comment.tokens_.get(i-1).text_.equals("Al+")) {
								Token previous = feature_comment.tokens_.get(i-1);
								previous.SetCoreferrent(true);
								previous.SetCoreferringTarget(antecedant_token);
							}
							node +=1;
							// go on to next token
							continue; 
						}
					}
					
					// Step 4
				    // If node X is the highest node in the sentence, traverse the surface parse trees
					// of previous sentences in the text in order of recency, the most recent first; each
					// tree is traversed in a left-to-right, breadth-first manner, and when an NP node
					// is encountered, it is proposed as antecedant. If X is not the highest S node in
					// the sentence, continue to step 5.
					// 
					// I will ignore this step because we only have one sentence, technically speaking
					// if we keep going up from S we'll find another S node.
					
					// I am going to put steps 5-8 in here and exit when we get to root or find the antecedant
				    boolean found_antecedant = false;
				   while (!found_antecedant && ! ((Element) X.getParentNode()).getAttribute("value").equals("ROOT")) {
					// Step 5
					// From node X, go up the tree to the first NP or S node encountered. Call this new node X,
					// and call the path traversed to reach it p.
					P = X;
					X = (Element) X.getParentNode();
					while (!X.getAttribute("value").equals("NP") && !X.getAttribute("value").equals("S")) {
						P = X;
						X = (Element) X.getParentNode();
					}
					
					// Step 6
					// If X is an NP node and if the path p to X did not pass through the N node that X immediately
					// dominates, propose X as the antecedant.
					// Will assume that if the left sibling has the N node, then P doesn't
					antecedant = AntecedantStep6(X,P);
					if (antecedant!=null) {
							antecedant_node = HeadNounIndexFromNPNode(antecedant, leaf_list);
							if (antecedant_node == -1) {
								System.out.println("Antecedant index is -1 :( ");
								antecedant = null;
							}
							Token t2 = feature_comment.tokens_.get(antecedant_node);
							if (!CoreferenceFeatures.MatchGenderArabic(t, t2) 
								|| !CoreferenceFeatures.MatchNumberArabic(t, t2) 
								|| !CoreferenceFeatures.MatchPersonArabic(t, t2)) {
								System.out.println("Antecedant doesn't match gender, number, or person! "
										+ "Moving on to next rule");
								System.out.println("Pronoun:" + t.text_);
								System.out.println("Antecedant:" + t2.text_);
								antecedant = null;
							} else {
								System.out.println("Found antecedant!");
								antecedant_token = t2;
								// Passed, make all updates
								found_antecedant = true;
								t.SetCoreferrent(true);
								t.SetCoreferringTarget(antecedant_token);
								System.out.println("Pronoun:" + t.text_);
								System.out.println("Antecedant:" + antecedant_token.text_);
								if (i>0 && feature_comment.tokens_.get(i-1).text_.equals("Al+")) {
									// actually won't be likely since it's a pronoun
									Token previous = feature_comment.tokens_.get(i-1);
									previous.SetCoreferrent(true);
									previous.SetCoreferringTarget(antecedant_token);
								}
								node +=1;
								// go on to next token
								break; // break this while loop
								//continue; 
							}
						}
	
					 // end step 6
					
					// Step 7
					// Traverse all branches below node X to the left of path p in a left-to-right,
					// breadth-first manner. Propose any NP node encountered as the antecedent.
					//
					// Almost done!
					antecedant = AntecedantStep7(X,P);
					if (antecedant!=null) {
						antecedant_node = HeadNounIndexFromNPNode(antecedant, leaf_list);
						if (antecedant_node == -1) {
							System.out.println("Antecedant index is -1 :( ");
							antecedant = null;
						}
						Token t2 = feature_comment.tokens_.get(antecedant_node);
						if (!CoreferenceFeatures.MatchGenderArabic(t, t2) 
							|| !CoreferenceFeatures.MatchNumberArabic(t, t2) 
							|| !CoreferenceFeatures.MatchPersonArabic(t, t2)) {
							System.out.println("Antecedant doesn't match gender, number, or person! "
									+ "Moving on to next rule");
							System.out.println("Pronoun:" + t.text_);
							System.out.println("Antecedant:" + t2.text_);
							antecedant = null;
						} else {
							System.out.println("Found antecedant!");
							antecedant_token = t2;
							// Passed, make all updates
							found_antecedant = true;
							t.SetCoreferrent(true);
							t.SetCoreferringTarget(antecedant_token);
							System.out.println("Pronoun:" + t.text_);
							System.out.println("Antecedant:" + antecedant_token.text_);
							if (i>0 && feature_comment.tokens_.get(i-1).text_.equals("Al+")) {
								Token previous = feature_comment.tokens_.get(i-1);
								previous.SetCoreferrent(true);
								previous.SetCoreferringTarget(antecedant_token);
							}
							node +=1;
							break; // break while loop
							//continue; 
						}
					}
					
					
				// Step 8
				// If X is an S node, traverse all branches of node X to the *right* of path p in 
				// a left-to-right, breadth-first manner, but do not go below any NP or S node
				// encountered. Propose any NP node encountered as the antecedent. 
				antecedant = AntecedantStep8(X,P);
				if (antecedant!=null) {
					antecedant_node = HeadNounIndexFromNPNode(antecedant, leaf_list);
					if (antecedant_node == -1) {
						System.out.println("Antecedant index is -1 :( ");
						antecedant = null;
					}
					Token t2 = feature_comment.tokens_.get(antecedant_node);
					if (!CoreferenceFeatures.MatchGenderArabic(t, t2) 
						|| !CoreferenceFeatures.MatchNumberArabic(t, t2) 
						|| !CoreferenceFeatures.MatchPersonArabic(t, t2)) {
						System.out.println("Antecedant doesn't match gender, number, or person! "
								+ "Moving on to next rule");
						System.out.println("Pronoun:" + t.text_);
						System.out.println("Antecedant:" + t2.text_);
						antecedant = null;
					} else {
						System.out.println("Found antecedant!");
						antecedant_token = t2;
						// Passed, make all updates
						t.SetCoreferrent(true);
						t.SetCoreferringTarget(antecedant_token);
						System.out.println("Pronoun:" + t.text_);
						System.out.println("Antecedant:" + antecedant_token.text_);
						if (i>0 && feature_comment.tokens_.get(i-1).text_.equals("Al+")) {
							Token previous = feature_comment.tokens_.get(i-1);
							previous.SetCoreferrent(true);
							previous.SetCoreferringTarget(antecedant_token);
						}
						node +=1;
						break; // break while loop
						// go on to next token
						//continue; 
					}
				}
			
			} // end while loop for steps 5-8
			if (found_antecedant) {
				continue;
				// go to next token
			}
			node +=1; 
			
		} // end if PRP
	} // end loop
			
		return feature_comment;
	}
	
	// Returns the node index of the parse tree that corefers with the pronoun
	/*public static int FindAntecedant(Element pronoun, Token t, Node parse_tree) {
		return 0;
	}*/
	
	// Returns the index of the head noun given this NP node
	// NN, NNS (noun, plural!), NNP (proper noun singular), 
	// NNPS (proper noun plural), DTNN, DTNNS, DTNNP, DTNNPS ...
	// probably won't need nodes just leafs
	public static int HeadNounIndexFromNPNode(Element antecedant_node, List<Node> leafs) {
		int index = -1;
		Element child = (Element) antecedant_node.getFirstChild();
		while ( !child.getAttribute("value").equals("NN") 
				&& !child.getAttribute("value").equals("NNS") 
				&& !child.getAttribute("value").equals("NNP") 
				&& !child.getAttribute("value").equals("NNPS")
				&& !child.getAttribute("value").equals("DTNN")
				&& !child.getAttribute("value").equals("DTNNS")
				&& !child.getAttribute("value").equals("DTNNP")
				&& !child.getAttribute("value").equals("DTNNPS")
				&& child!=null) {
			child = (Element) child.getNextSibling();
		}
		while (child.hasChildNodes()) {
			// should only have one child at this point
			child = (Element) child.getFirstChild();
		}
		if (child == null || !leafs.contains((Node) child)) {
			System.out.println("Hobbs: Tried to find the head noun,"
					+ " but turns out leafs doesn't contain this child.");
		}
		if (index!=-1) {
			index = leafs.indexOf(child);
		}
			
		return index;
	}
	

	
	public HobbsCoreference() {
		// TODO Auto-generated constructor stub
	}
	
	static List<Node> GetLeafList (NodeList leafs) {
		List<Node> visited_leafs = new ArrayList<Node>();
		// Set tokens for comment and store leaf node
		for (int n=0;n<leafs.getLength(); n++) {
			visited_leafs.add(leafs.item(n));
	}
		return visited_leafs;
	}
	
	

}

// Consider different types of Arabic pronouns



	
	// have to pass the node?
	/*public static Element AntecedantStep3(Node X, Node P) {
		Element antecedant = null;
		Node first_child_node = X.getFirstChild();
		Node left_child_node = first_child_node;
		Element left_child = null;
		Element first_child = null;
		
		if (first_child_node.getNodeType() == Node.ELEMENT_NODE) {
			first_child = (Element) first_child_node;
			left_child = (Element) left_child_node;
			System.out.println("Step 3: Left child:" + left_child.getAttribute("value"));
		} else{
			System.out.println("Can't cast first child node to element!");
		}
			 
		if (!left_child_node.equals(P)) {
			while (left_child_node != null) {
				if (left_child.getAttribute("value").equals("NP")) {
				// check if there is NP node between left child and X, go up the tree again
					Node potential_parent_node = left_child_node.getParentNode();
					Element potential_parent = (Element) potential_parent_node;
					//Element potential_parent = (Element) left_child.getParentNode();
					while (!potential_parent_node.equals(X)) {
						if (potential_parent.getAttribute("value").equals("NP")
								|| potential_parent.getAttributeNode("value").equals("S")) {
							
							antecedant = left_child;
							break;
							// also match
						}
						potential_parent_node = potential_parent_node.getParentNode();
						potential_parent = (Element) potential_parent_node;
						//potential_parent = (Element) potential_parent.getParentNode();
					}
				}
				if (antecedant != null) {
					break;
				}
				if (left_child_node.getNextSibling()==null || left_child_node.getNextSibling().equals(P)) {
					// Go to uncle or aunt tree
					if (!left_child_node.getNextSibling().equals(P) && left_child_node.getParentNode().getNextSibling()!=null
							&& !left_child_node.getParentNode().getNextSibling().equals(P)) {
						left_child_node =  left_child_node.getParentNode().getNextSibling().getFirstChild();
						first_child_node = left_child_node;
						left_child = (Element) left_child_node;
						first_child = (Element) first_child_node;
					} 
					else {
						// Go to next level in tree
						left_child_node = first_child_node.getFirstChild();
						first_child_node = left_child_node;
						left_child = (Element) left_child_node;
						first_child = (Element) left_child;
					}
				 } 
				else {
					left_child_node = left_child_node.getNextSibling(); 
					left_child = (Element) left_child_node;
				}
			}  // If left child is still null, no more children, so exit
		}  // If P is the only child, do nothing
		return antecedant;
	}*/